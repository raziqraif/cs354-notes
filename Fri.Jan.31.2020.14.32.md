# High level view of interrupts

```
                   Interrupts 
                   ==========
System calls     App processes
     ||       +-------------------+
     \/       |  Upper half       |               
              +-------------------+<---- OS
              |  lower half       |
     /\       +-------------------+
     ||======== Hardware ex: clock, cpu, ethernet, etc.
	            These generate interrupts
                                                  
```

So if there is a hardware clock that generates an interrupt every 1ms, the OS handles the interrupt with OS code. When apps make system calls the OS handles the kernel system call functionality.

If a syscall has more calls associated with it, the kernel handles those functions with *internal* kernel functions in the upper half.

If an interrupt handler has more calls associated with it, the kernel handles those functions with *internal* kernal functions in the lower half. There are exceptions to both of these rules.

CPU can generate an interrupt, ex: when a process divides by zero, the cpu detects that a div/0 has occured, and generates an interrupt.

Reminder from 250 we know execution is: 

```
fetch->decode->execute---
^                       |
|------------------------
```

Interrupts squeeze into this sequence after execute

Two types of interrupts:
- Synchronous (generated by the currently running instruction)
- Asynchronous (generated by something else [could be almost anything])

OS has to tell the hardware where in memory the interrupt handlers are located. In x86, we do the following during bootstrapping (this is I assume a particular location in memory but park didn't say what it was) this is called the interrupt descriptor table. There is a CPU register IDTR that holds the address of the table and its only purpose is to be told where the table is located. It's a register so that interrupt running can be done very quickly.


| ... |
|---| 
| start of interrupt table (size 256) |
| address of kernel function for _Xtrap0 |
| address of kernel function for _Xtrap1 |
| address of kernel function for _Xtrap2 |
| ... |
| end of interrupt table |
| ... |

(Park rides an Indian motorcycle I knew he was a G)

In the clock example, pid 5000 is running and the clock causes an interrupt (int 33). The hardware knows to jump to the function associated with the interrupt. The process changes to kernel mode and runs the interrupt code. It then returns from the kernel function back to where the application was. The process didn't ask for the interrupt, it was forcefully interrupted, so we must return cleanly. 

*need to go check whether higher or lower priority runs first* it's unclear whether higher value = higher priority or lower value = lower priority

The OS requirement is that after bootstrapping, everything must be run as a process. So even if there are no user processes running, there must still be a single kernel process (with the lowest priority), the null process, so that interrupts can still be handled.

Null process is also called "Idle process". 

# Isolation + Protection (First real topic of course)

Isolation: When one process crashes, we don't want the whole system to crash or be negatively impacted.

To protect, we have a sandbox

```mermaid
graph LR;
	7000-->5000;
	5000-->371;
```

So that when process 5000 crashes, let it crash but don't crash the whole system by using the sandbox. Make sure that kernel code is well written so that full OS crashes don't happen.

To make Isolation/Protection work we need 4 features:
- Kernel Mode and User Mode (These are hardware states)
- Processes run in user mode when started with no exceptions
- Memory protection
-

Example, if you call fork(), eventually you'll hit an instruction that needs to jump to kernel code. This instruction is called a trap instruction.

Trap is always 2 things: jump to kernel mode and set kernel mode then jump back and unset kernel mode

